"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var bn_js_1 = tslib_1.__importDefault(require("bn.js"));
var web3_1 = tslib_1.__importDefault(require("web3"));
var __1 = require("..");
// Helper function to create a user instance.
// User friendly wrapper for all Entity related functions, taking advantage of the database
var User = /** @class */ (function (_super) {
    tslib_1.__extends(User, _super);
    function User(web3, params, startBlock) {
        var _this = _super.call(this, web3, params) || this;
        _this._startBlock = startBlock;
        return _this;
    }
    Object.defineProperty(User, "contractName", {
        set: function (contractName) {
            User._contractName = contractName;
        },
        enumerable: true,
        configurable: true
    });
    User.createUser = function (web3Endpoint, plasmaAddress, dappchainEndpoint, ethPrivateKey, startBlock) {
        var provider = new web3_1.default.providers.WebsocketProvider(web3Endpoint);
        var web3 = new web3_1.default(provider);
        var database = new __1.PlasmaDB(web3Endpoint, dappchainEndpoint, plasmaAddress, ethPrivateKey);
        var ethAccount = web3.eth.accounts.privateKeyToAccount(ethPrivateKey);
        var ethPlasmaClient = new __1.EthereumPlasmaClient(web3, ethAccount, plasmaAddress);
        var writer = __1.createJSONRPCClient({ protocols: [{ url: dappchainEndpoint + '/rpc' }] });
        var reader = __1.createJSONRPCClient({ protocols: [{ url: dappchainEndpoint + '/query' }] });
        var dAppClient = new __1.Client('default', writer, reader);
        // TODO: Key should not be generated each time, user should provide their key, or it should be retrieved through some one way mapping
        var privKey = __1.CryptoUtils.generatePrivateKey();
        var pubKey = __1.CryptoUtils.publicKeyFromPrivateKey(privKey);
        dAppClient.txMiddleware = [
            new __1.NonceTxMiddleware(pubKey, dAppClient),
            new __1.SignedTxMiddleware(privKey)
        ];
        var callerAddress = new __1.Address('default', __1.LocalAddress.fromPublicKey(pubKey));
        var dAppPlasmaClient = new __1.DAppChainPlasmaClient({
            dAppClient: dAppClient,
            callerAddress: callerAddress,
            database: database,
            contractName: User._contractName
        });
        return new User(web3, {
            ethAccount: ethAccount,
            ethPlasmaClient: ethPlasmaClient,
            dAppPlasmaClient: dAppPlasmaClient,
            childBlockInterval: 1000
        }, startBlock);
    };
    // Transfer a coin by specifying slot & new owner
    User.prototype.transferAsync = function (slot, newOwner) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, prevBlockNum, blockNum;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.findBlocks(slot)];
                    case 1:
                        _a = _b.sent(), prevBlockNum = _a.prevBlockNum, blockNum = _a.blockNum;
                        return [4 /*yield*/, this.transferTokenAsync({
                                slot: slot,
                                prevBlockNum: blockNum,
                                denomination: 1,
                                newOwner: newOwner
                            })];
                    case 2:
                        _b.sent();
                        return [2 /*return*/, this.getCurrentBlockAsync()];
                }
            });
        });
    };
    User.prototype.verifyInclusionAsync = function (slot, block) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var tx, root;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getPlasmaTxAsync(slot, block)]; // get the block number from the proof of inclusion and get the tx from that
                    case 1:
                        tx = _a.sent() // get the block number from the proof of inclusion and get the tx from that
                        ;
                        return [4 /*yield*/, this.getBlockRootAsync(block)];
                    case 2:
                        root = _a.sent();
                        return [2 /*return*/, this.checkInclusionAsync(tx, root, slot, tx.proof)];
                }
            });
        });
    };
    // Exiting a coin by specifying the slot. Finding the block numbers is done under the hood.
    User.prototype.exitAsync = function (slot) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, prevBlockNum, blockNum;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.findBlocks(slot)];
                    case 1:
                        _a = _b.sent(), prevBlockNum = _a.prevBlockNum, blockNum = _a.blockNum;
                        return [4 /*yield*/, this.startExitAsync({
                                slot: slot,
                                prevBlockNum: prevBlockNum,
                                exitBlockNum: blockNum
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                }
            });
        });
    };
    // Get all deposits, filtered by the user's address.
    User.prototype.deposits = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getDepositEvents(this._startBlock || new bn_js_1.default(0), false)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    User.prototype.allDeposits = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getDepositEvents(this._startBlock || new bn_js_1.default(0), true)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    User.prototype.disconnect = function () {
        // @ts-ignore
        this.web3.currentProvider.connection.close();
    };
    User.prototype.debug = function (i) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var deps;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.allDeposits()];
                    case 1:
                        deps = _a.sent();
                        return [4 /*yield*/, this.submitPlasmaDepositAsync(deps[i])];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    User.prototype.findBlocks = function (slot) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var coinData, lastUserBlock, blockNum, prevBlockNum, i, coin, e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getCoinHistoryFromDBAsync(slot)];
                    case 1:
                        coinData = _a.sent();
                        lastUserBlock = this.database.getBlock(slot);
                        if (!(lastUserBlock === undefined)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.getCurrentBlockAsync()];
                    case 2:
                        lastUserBlock = _a.sent();
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 4, , 6]);
                        blockNum = coinData[0].blockNumber;
                        prevBlockNum = coinData[0].tx.prevBlockNum;
                        for (i = 1; i < coinData.length; i++) {
                            coin = coinData[i];
                            if (!coin.included)
                                continue; // skip exclusion proofs
                            if (lastUserBlock.lt(coin.blockNumber)) {
                                // in case the malicious operator includes invalid/double spends,
                                // we want to get the last legitimate state, so we stop iterating
                                break;
                            }
                            if (coin.blockNumber.gt(blockNum)) {
                                blockNum = coin.blockNumber;
                                prevBlockNum = coin.tx.prevBlockNum;
                            }
                        }
                        return [3 /*break*/, 6];
                    case 4:
                        e_1 = _a.sent();
                        // If no coindata is available in the database, then that's a new coin
                        prevBlockNum = new bn_js_1.default(0);
                        return [4 /*yield*/, this.getPlasmaCoinAsync(slot)];
                    case 5:
                        blockNum = (_a.sent()).depositBlockNum;
                        return [3 /*break*/, 6];
                    case 6: return [2 /*return*/, { prevBlockNum: prevBlockNum, blockNum: blockNum }];
                }
            });
        });
    };
    User.prototype.getCoinHistoryFromDBAsync = function (slot) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var coin;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getPlasmaCoinAsync(slot)
                        // Update the local database
                    ];
                    case 1:
                        coin = _a.sent();
                        // Update the local database
                        return [4 /*yield*/, this.checkHistoryAsync(coin)];
                    case 2:
                        // Update the local database
                        _a.sent();
                        return [2 /*return*/, this.database.getCoin(slot)];
                }
            });
        });
    };
    return User;
}(__1.Entity));
exports.User = User;
//# sourceMappingURL=user.js.map